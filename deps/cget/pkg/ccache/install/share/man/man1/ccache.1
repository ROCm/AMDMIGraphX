'\" t
.\"     Title: ccache
.\"    Author: [see the "Author" section]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 10/12/2022
.\"    Manual: ccache Manual
.\"    Source: ccache 4.1
.\"  Language: English
.\"
.TH "CCACHE" "1" "10/12/2022" "ccache 4\&.1" "ccache Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ccache \- a fast C/C++ compiler cache
.SH "SYNOPSIS"
.sp
.nf
\fBccache\fR [\fIoptions\fR]
\fBccache\fR \fIcompiler\fR [\fIcompiler options\fR]
\fIcompiler\fR [\fIcompiler options\fR]                   (via symbolic link)
.fi
.SH "DESCRIPTION"
.sp
Ccache is a compiler cache\&. It speeds up recompilation by caching the result of previous compilations and detecting when the same compilation is being done again\&.
.sp
Ccache has been carefully written to always produce exactly the same compiler output that you would get without the cache\&. The only way you should be able to tell that you are using ccache is the speed\&. Currently known exceptions to this goal are listed under CAVEATS\&. If you discover an undocumented case where ccache changes the output of your compiler, please let us know\&.
.SH "RUN MODES"
.sp
There are two ways to use ccache\&. You can either prefix your compilation commands with \fBccache\fR or you can let ccache masquerade as the compiler by creating a symbolic link (named as the compiler) to ccache\&. The first method is most convenient if you just want to try out ccache or wish to use it for some specific projects\&. The second method is most useful for when you wish to use ccache for all your compilations\&.
.sp
To use the first method, just make sure that \fBccache\fR is in your \fBPATH\fR\&.
.sp
To use the symlinks method, do something like this:
.sp
.if n \{\
.RS 4
.\}
.nf
cp ccache /usr/local/bin/
ln \-s ccache /usr/local/bin/gcc
ln \-s ccache /usr/local/bin/g++
ln \-s ccache /usr/local/bin/cc
ln \-s ccache /usr/local/bin/c++
.fi
.if n \{\
.RE
.\}
.sp
And so forth\&. This will work as long as the directory with symlinks comes before the path to the compiler (which is usually in \fB/usr/bin\fR)\&. After installing you may wish to run \(lqwhich gcc\(rq to make sure that the correct link is being used\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
.sp
The technique of letting ccache masquerade as the compiler works well, but currently doesn\(cqt interact well with other tools that do the same thing\&. See USING CCACHE WITH OTHER COMPILER WRAPPERS\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
.sp
Use a symbolic links for masquerading, not hard links\&.
.sp .5v
.RE
.SH "COMMAND LINE OPTIONS"
.sp
These command line options only apply when you invoke ccache as \(lqccache\(rq\&. When invoked as a compiler (via a symlink as described in the previous section), the normal compiler options apply and you should refer to the compiler\(cqs documentation\&.
.SS "Common options"
.PP
\fB\fB\-c\fR\fR, \fB\fB\-\-cleanup\fR\fR
.RS 4
Clean up the cache by removing old cached files until the specified file number and cache size limits are not exceeded\&. This also recalculates the cache file count and size totals\&. Normally, there is no need to initiate cleanup manually as ccache keeps the cache below the specified limits at runtime and keeps statistics up to date on each compilation\&. Forcing a cleanup is mostly useful if you manually modify the cache contents or believe that the cache size statistics may be inaccurate\&.
.RE
.PP
\fB\fB\-C\fR\fR, \fB\fB\-\-clear\fR\fR
.RS 4
Clear the entire cache, removing all cached files, but keeping the configuration file\&.
.RE
.PP
\fB\fB\-\-config\-path\fR\fR \fIPATH\fR
.RS 4
Let the subsequent command line options operate on configuration file
\fIPATH\fR
instead of the default\&. Using this option has the same effect as setting the environment variable
\fBCCACHE_CONFIGPATH\fR
temporarily\&.
.RE
.PP
\fB\fB\-d\fR\fR, \fB\fB\-\-directory\fR\fR \fIPATH\fR
.RS 4
Let the subsequent command line options operate on cache directory
\fIPATH\fR
instead of the default\&. For example, to show statistics for a cache directory at
\fB/shared/ccache\fR
you can run
\fBccache \-d /shared/ccache \-s\fR\&. Using this option has the same effect as setting the environment variable
\fBCCACHE_DIR\fR
temporarily\&.
.RE
.PP
\fB\fB\-\-evict\-older\-than\fR\fR \fIAGE\fR
.RS 4
Remove files older than
\fIAGE\fR
from the cache\&.
\fIAGE\fR
should be an unsigned integer with a
\fBd\fR
(days) or
\fBs\fR
(seconds) suffix\&.
.RE
.PP
\fB\fB\-h\fR\fR, \fB\fB\-\-help\fR\fR
.RS 4
Print a summary of command line options\&.
.RE
.PP
\fB\fB\-F\fR\fR \fINUM\fR, \fB\fB\-\-max\-files\fR\fR \fINUM\fR
.RS 4
Set the maximum number of files allowed in the cache to
\fINUM\fR\&. Use 0 for no limit\&. The value is stored in a configuration file in the cache directory and applies to all future compilations\&.
.RE
.PP
\fB\fB\-M\fR\fR \fISIZE\fR, \fB\fB\-\-max\-size\fR\fR \fISIZE\fR
.RS 4
Set the maximum size of the files stored in the cache\&.
\fISIZE\fR
should be a number followed by an optional suffix: k, M, G, T (decimal), Ki, Mi, Gi or Ti (binary)\&. The default suffix is G\&. Use 0 for no limit\&. The value is stored in a configuration file in the cache directory and applies to all future compilations\&.
.RE
.PP
\fB\fB\-X\fR\fR \fILEVEL\fR, \fB\fB\-\-recompress\fR\fR \fILEVEL\fR
.RS 4
Recompress the cache using compression level
\fILEVEL\fR\&. The level can be an integer, with the same semantics as the
\fBcompression_level\fR
configuration setting), or the special value
\fBuncompressed\fR
for no compression\&. See
CACHE COMPRESSION
for more information\&. This can potentionally take a long time since all files in the cache need to be visited\&. Only files that are currently compressed with a different level than
\fILEVEL\fR
will be recompressed\&.
.RE
.PP
\fB\fB\-o\fR\fR \fIKEY=VALUE\fR, \fB\fB\-\-set\-config\fR\fR \fIKEY\fR=\fIVALUE\fR
.RS 4
Set configuration option
\fIKEY\fR
to
\fIVALUE\fR\&. See
CONFIGURATION
for more information\&.
.RE
.PP
\fB\fB\-x\fR\fR, \fB\fB\-\-show\-compression\fR\fR
.RS 4
Print cache compression statistics\&. See
CACHE COMPRESSION
for more information\&. This can potentionally take a long time since all files in the cache need to be visited\&.
.RE
.PP
\fB\fB\-p\fR\fR, \fB\fB\-\-show\-config\fR\fR
.RS 4
Print current configuration options and from where they originate (environment variable, configuration file or compile\-time default) in human\-readable format\&.
.RE
.PP
\fB\fB\-s\fR\fR, \fB\fB\-\-show\-stats\fR\fR
.RS 4
Print a summary of configuration and statistics counters in human\-readable format\&.
.RE
.PP
\fB\fB\-V\fR\fR, \fB\fB\-\-version\fR\fR
.RS 4
Print version and copyright information\&.
.RE
.PP
\fB\fB\-z\fR\fR, \fB\fB\-\-zero\-stats\fR\fR
.RS 4
Zero the cache statistics (but not the configuration options)\&.
.RE
.SS "Options for scripting or debugging"
.PP
\fB\fB\-\-checksum\-file\fR\fR \fIPATH\fR
.RS 4
Print the checksum (64 bit XXH3) of the file at
\fIPATH\fR\&.
.RE
.PP
\fB\fB\-\-dump\-manifest\fR\fR \fIPATH\fR
.RS 4
Dump manifest file at
\fIPATH\fR
in text format to standard output\&. This is only useful when debugging ccache and its behavior\&.
.RE
.PP
\fB\fB\-\-dump\-result\fR\fR \fIPATH\fR
.RS 4
Dump result file at
\fIPATH\fR
in text format to standard output\&. This is only useful when debugging ccache and its behavior\&.
.RE
.PP
\fB\fB\-\-extract\-result\fR\fR \fIPATH\fR
.RS 4
Extract data stored in the result file at
\fIPATH\fR\&. The data will be written to
\fBccache\-result\&.\fR* files in to the current working directory\&. This is only useful when debugging ccache and its behavior\&.
.RE
.PP
\fB\fB\-k\fR\fR \fIKEY\fR, \fB\fB\-\-get\-config\fR\fR \fIKEY\fR
.RS 4
Print the value of configuration option
\fIKEY\fR\&. See
CONFIGURATION
for more information\&.
.RE
.PP
\fB\fB\-\-hash\-file\fR\fR \fIPATH\fR
.RS 4
Print the hash (160 bit BLAKE3) of the file at
\fIPATH\fR\&. This is only useful when debugging ccache and its behavior\&.
.RE
.PP
\fB\fB\-\-print\-stats\fR\fR
.RS 4
Print statistics counter IDs and corresponding values machine\-parsable (tab\-separated) format\&.
.RE
.SS "Extra options"
.sp
When run as a compiler, ccache usually just takes the same command line options as the compiler you are using\&. The only exception to this is the option \fB\-\-ccache\-skip\fR\&. That option can be used to tell ccache to avoid interpreting the next option in any way and to pass it along to the compiler as\-is\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
\fB\-\-ccache\-skip\fR currently only tells ccache not to interpret the next option as a special compiler option \(em the option will still be included in the direct mode hash\&.
.sp .5v
.RE
.sp
The reason this can be important is that ccache does need to parse the command line and determine what is an input filename and what is a compiler option, as it needs the input filename to determine the name of the resulting object file (among other things)\&. The heuristic ccache uses when parsing the command line is that any argument that exists as a file is treated as an input file name\&. By using \fB\-\-ccache\-skip\fR you can force an option to not be treated as an input file name and instead be passed along to the compiler as a command line option\&.
.sp
Another case where \fB\-\-ccache\-skip\fR can be useful is if ccache interprets an option specially but shouldn\(cqt, since the option has another meaning for your compiler than what ccache thinks\&.
.SH "CONFIGURATION"
.sp
ccache\(cqs default behavior can be overridden by settings in configuration files, which in turn can be overridden by environment variables with names starting with \fBCCACHE_\fR\&. Ccache normally reads configuration from two files: first a system\-level configuration file and secondly a cache\-specific configuration file\&. The priority of configuration settings is as follows (where 1 is highest):
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Environment variables\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
The primary (cache\-specific) configuration file (see below)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
The secondary (system\-wide read\-only) configuration file
\fB\fI<sysconfdir>\fR\fR\fB/ccache\&.conf\fR
(typically
\fB/etc/ccache\&.conf\fR
or
\fB/usr/local/etc/ccache\&.conf\fR)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Compile\-time defaults\&.
.RE
.sp
As a special case, if the the environment variable \fBCCACHE_CONFIGPATH\fR is set it specifies the primary configuration file and the secondary (system\-wide) configuration file won\(cqt be read\&.
.SS "Location of the primary configuration file"
.sp
The location of the primary (cache\-specific) configuration is determined like this:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
If
\fBCCACHE_CONFIGPATH\fR
is set, use that path\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Otherwise, if
\fBcache_dir\fR
(\fBCCACHE_DIR\fR) is set then use
\fB<ccache_dir>/ccache\&.conf\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Otherwise, if there is a legacy
\fB$HOME/\&.ccache\fR
directory then use
\fB$HOME/\&.ccache/ccache\&.conf\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Otherwise, if
\fBXDG_CONFIG_HOME\fR
is set then use
\fB$XDG_CONFIG_HOME/ccache/ccache\&.conf\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
Otherwise, use
\fB%APPDATA%/ccache/ccache\&.conf\fR
(Windows),
\fB$HOME/Library/Preferences/ccache/ccache\&.conf\fR
(macOS) or
\fB$HOME/\&.config/ccache/ccache\&.conf\fR
(other systems)\&.
.RE
.SS "Configuration file syntax"
.sp
Configuration files are in a simple \(lqkey = value\(rq format, one setting per line\&. Lines starting with a hash sign are comments\&. Blank lines are ignored, as is whitespace surrounding keys and values\&. Example:
.sp
.if n \{\
.RS 4
.\}
.nf
# Set maximum cache size to 10 GB:
max_size = 10G
.fi
.if n \{\
.RE
.\}
.SS "Boolean values"
.sp
Some configuration options are boolean values (i\&.e\&. truth values)\&. In a configuration file, such values must be set to the string \fBtrue\fR or \fBfalse\fR\&. For the corresponding environment variables, the semantics are a bit different:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A set environment variable means \(lqtrue\(rq (even if set to the empty string)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The following case\-insensitive negative values are considered an error (instead of surprising the user):
\fB0\fR,
\fBfalse\fR,
\fBdisable\fR
and
\fBno\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An unset environment variable means \(lqfalse\(rq\&.
.RE
.sp
Each boolean environment variable also has a negated form starting with \fBCCACHE_NO\fR\&. For example, \fBCCACHE_COMPRESS\fR can be set to force compression and \fBCCACHE_NOCOMPRESS\fR can be set to force no compression\&.
.SS "Configuration options"
.sp
Below is a list of available configuration options\&. The corresponding environment variable name is indicated in parentheses after each configuration option key\&.
.PP
\fBabsolute_paths_in_stderr\fR (\fBCCACHE_ABSSTDERR\fR)
.RS 4
This option specifies whether ccache should rewrite relative paths in the compiler\(cqs standard error output to absolute paths\&. This can be useful if you use
\fBbase_dir\fR
with a build system (e\&.g\&. CMake with the "Unix Makefiles" generator) that executes the compiler in a different working directory, which makes relative paths in compiler errors or warnings incorrect\&. The default is false\&.
.RE
.PP
\fBbase_dir\fR (\fBCCACHE_BASEDIR\fR)
.RS 4
This option should be an absolute path to a directory\&. If set, ccache will rewrite absolute paths into paths relative to the current working directory, but only absolute paths that begin with
\fBbase_dir\fR\&. Cache results can then be shared for compilations in different directories even if the project uses absolute paths in the compiler command line\&. See also the discussion under
COMPILING IN DIFFERENT DIRECTORIES\&. If set to the empty string (which is the default), no rewriting is done\&.
.sp
A typical path to use as
\fBbase_dir\fR
is your home directory or another directory that is a parent of your project directories\&. Don\(cqt use
\fB/\fR
as the base directory since that will make ccache also rewrite paths to system header files, which typically is contraproductive\&.
.sp
For example, say that Alice\(cqs current working directory is
\fB/home/alice/project1/build\fR
and that she compiles like this:
.sp
.if n \{\
.RS 4
.\}
.nf
ccache gcc \-I/usr/include/example \-I/home/alice/project2/include \-c /home/alice/project1/src/example\&.c
.fi
.if n \{\
.RE
.\}
.sp
Here is what ccache will actually execute for different
\fBbase_dir\fR
values:
.sp
.if n \{\
.RS 4
.\}
.nf
# Current working directory: /home/alice/project1/build

# With base_dir = /:
gcc \-I\&.\&./\&.\&./\&.\&./\&.\&./usr/include/example \-I\&.\&./\&.\&./project2/include \-c \&.\&./src/example\&.c

# With base_dir = /home or /home/alice:
gcc \-I/usr/include/example \-I\&.\&./\&.\&./project2/include \-c \&.\&./src/example\&.c

# With base_dir = /home/alice/project1 or /home/alice/project1/src:
gcc \-I/usr/include/example \-I/home/alice/project2/include \-c \&.\&./src/example\&.c
.fi
.if n \{\
.RE
.\}
.sp
If Bob has put
\fBproject1\fR
and
\fBproject2\fR
in
\fB/home/bob/stuff\fR
and both users have set
\fBbase_dir\fR
to
\fB/home\fR
or
\fB/home/$USER\fR, then Bob will get a cache hit (if they share ccache directory) since the actual command line will be identical to that of Alice:
.sp
.if n \{\
.RS 4
.\}
.nf
# Current working directory: /home/bob/stuff/project1/build

# With base_dir = /home or /home/bob:
gcc \-I/usr/include/example \-I\&.\&./\&.\&./project2/include \-c \&.\&./src/example\&.c
.fi
.if n \{\
.RE
.\}
.sp
Without
\fBbase_dir\fR
there will be a cache miss since the absolute paths will differ\&. With
\fBbase_dir\fR
set to
\fB/\fR
there will be a cache miss since the relative path to
\fB/usr/include/example\fR
will be different\&. With
\fBbase_dir\fR
set to
\fB/home/bob/stuff/project1\fR
there will a cache miss since the path to project2 will be a different absolute path\&.
.RE
.PP
\fBcache_dir\fR (\fBCCACHE_DIR\fR)
.RS 4
This option specifies where ccache will keep its cached compiler outputs\&. It will only take effect if set in the system\-wide configuration file or as an environment variable\&. The default is
\fB$XDG_CACHE_HOME/ccache\fR
if
\fBXDG_CACHE_HOME\fR
is set, otherwise
\fB$HOME/\&.cache/ccache\fR\&. Exception: If the legacy directory
\fB$HOME/\&.ccache\fR
exists then that directory is the default\&.
.sp
.if n \{\
.RS 4
.\}
.nf
See also <<_location_of_the_primary_configuration_file,LOCATION OF THE
PRIMARY CONFIGURATION FILE>>\&.
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
If you want to use another *CCACHE_DIR* value temporarily for one ccache
invocation you can use the `\-d/\-\-directory` command line option instead\&.
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBcompiler\fR (\fBCCACHE_COMPILER\fR or (deprecated) \fBCCACHE_CC\fR)
.RS 4
This option can be used to force the name of the compiler to use\&. If set to the empty string (which is the default), ccache works it out from the command line\&.
.RE
.PP
\fBcompiler_check\fR (\fBCCACHE_COMPILERCHECK\fR)
.RS 4
By default, ccache includes the modification time (\(lqmtime\(rq) and size of the compiler in the hash to ensure that results retrieved from the cache are accurate\&. This option can be used to select another strategy\&. Possible values are:
.PP
\fBcontent\fR
.RS 4
Hash the content of the compiler binary\&. This makes ccache very slightly slower compared to
\fBmtime\fR, but makes it cope better with compiler upgrades during a build bootstrapping process\&.
.RE
.PP
\fBmtime\fR
.RS 4
Hash the compiler\(cqs mtime and size, which is fast\&. This is the default\&.
.RE
.PP
\fBnone\fR
.RS 4
Don\(cqt hash anything\&. This may be good for situations where you can safely use the cached results even though the compiler\(cqs mtime or size has changed (e\&.g\&. if the compiler is built as part of your build system and the compiler\(cqs source has not changed, or if the compiler only has changes that don\(cqt affect code generation)\&. You should only use
\fBnone\fR
if you know what you are doing\&.
.RE
.PP
\fBstring:value\fR
.RS 4
Use
\fBvalue\fR
as the string to calculate hash from\&. This can be the compiler revision number you retrieved earlier and set here via environment variable\&.
.RE
.PP
\fIa command string\fR
.RS 4
Hash the standard output and standard error output of the specified command\&. The string will be split on whitespace to find out the command and arguments to run\&. No other interpretation of the command string will be done, except that the special word
\fB%compiler%\fR
will be replaced with the path to the compiler\&. Several commands can be specified with semicolon as separator\&. Examples:
.sp
.if n \{\
.RS 4
.\}
.nf
%compiler% \-v
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
%compiler% \-dumpmachine; %compiler% \-dumpversion
.fi
.if n \{\
.RE
.\}
.sp
You should make sure that the specified command is as fast as possible since it will be run once for each ccache invocation\&.
.sp
Identifying the compiler using a command is useful if you want to avoid cache misses when the compiler has been rebuilt but not changed\&.
.sp
Another case is when the compiler (as seen by ccache) actually isn\(cqt the real compiler but another compiler wrapper \(em in that case, the default
\fBmtime\fR
method will hash the mtime and size of the other compiler wrapper, which means that ccache won\(cqt be able to detect a compiler upgrade\&. Using a suitable command to identify the compiler is thus safer, but it\(cqs also slower, so you should consider continue using the
\fBmtime\fR
method in combination with the
\fBprefix_command\fR
option if possible\&. See
USING CCACHE WITH OTHER COMPILER WRAPPERS\&.
.RE
.RE
.PP
\fBcompiler_type\fR (\fBCCACHE_COMPILERTYPE\fR)
.RS 4
Ccache normally guesses the compiler type based on the compiler name\&. The
\fBcompiler_type\fR
option lets you force a compiler type\&. This can be useful if the compiler has a non\-standard name but is actually one of the known compiler types\&. Possible values are:
.PP
\fBauto\fR
.RS 4
Guess one of the types below based on the compiler name (following symlinks)\&. This is the default\&.
.RE
.PP
\fBclang\fR
.RS 4
Clang\-based compiler\&.
.RE
.PP
\fBgcc\fR
.RS 4
GCC\-based compiler\&.
.RE
.PP
\fBnvcc\fR
.RS 4
NVCC (CUDA) compiler\&.
.RE
.PP
*other
.RS 4
Any compiler other than the known types\&.
.RE
.PP
\fBpump\fR
.RS 4
distcc\(cqs "pump" script\&.
.RE
.RE
.PP
\fBcompression\fR (\fBCCACHE_COMPRESS\fR or \fBCCACHE_NOCOMPRESS\fR, see Boolean values above)
.RS 4
If true, ccache will compress data it puts in the cache\&. However, this option has no effect on how files are retrieved from the cache; compressed and uncompressed results will still be usable regardless of this option\&. The default is true\&.
.sp
Compression is done using the Zstandard algorithm\&. The algorithm is fast enough that there should be little reason to turn off compression to gain performance\&. One exception is if the cache is located on a compressed file system, in which case the compression performed by ccache of course is redundant\&.
.sp
Compression will be disabled if file cloning (the
\fBfile_clone\fR
option) or hard linking (the
\fBhard_link\fR
option) is enabled\&.
.RE
.PP
\fBcompression_level\fR (\fBCCACHE_COMPRESSLEVEL\fR)
.RS 4
This option determines the level at which ccache will compress object files using the real\-time compression algorithm Zstandard\&. It only has effect if
\fBcompression\fR
is enabled (which it is by default)\&. Zstandard is extremely fast for decompression and very fast for compression for lower compression levels\&. The default is 0\&.
.sp
Semantics of
\fBcompression_level\fR:
.PP
\fB> 0\fR
.RS 4
A positive value corresponds to normal Zstandard compression levels\&. Lower levels (e\&.g\&.
\fB1\fR) mean faster compression but worse compression ratio\&. Higher levels (e\&.g\&.
\fB19\fR) mean slower compression but better compression ratio\&. The maximum possible value depends on the libzstd version\&. Decompression speed is essentially the same for all levels\&.
.RE
.PP
\fB< 0\fR
.RS 4
A negative value corresponds to Zstandard\(cqs \(lqultra\-fast\(rq compression levels, which are even faster than level 1 but with less good compression ratios\&. For instance, level
\fB\-3\fR
corresponds to \(lq\-\-fast=3\(rq for the
\fBzstd\fR
command line tool\&.
.RE
.PP
\fB0\fR (default)
.RS 4
The value
\fB0\fR
means that ccache will choose a suitable level, currently
\fB1\fR\&.
.RE
.RE
.PP
\fBcpp_extension\fR (\fBCCACHE_EXTENSION\fR)
.RS 4
This option can be used to force a certain extension for the intermediate preprocessed file\&. The default is to automatically determine the extension to use for intermediate preprocessor files based on the type of file being compiled, but that sometimes doesn\(cqt work\&. For example, when using the \(lqaCC\(rq compiler on HP\-UX, set the cpp extension to
\fBi\fR\&.
.RE
.PP
\fBdebug\fR (\fBCCACHE_DEBUG\fR or \fBCCACHE_NODEBUG\fR, see Boolean values above)
.RS 4
If true, enable the debug mode\&. The debug mode creates per\-object debug files that are helpful when debugging unexpected cache misses\&. Note however that ccache performance will be reduced slightly\&. See
debugging
for more information\&. The default is false\&.
.RE
.PP
\fBdepend_mode\fR (\fBCCACHE_DEPEND\fR or \fBCCACHE_NODEPEND\fR, see Boolean values above)
.RS 4
If true, the depend mode will be used\&. The default is false\&. See
THE DEPEND MODE\&.
.RE
.PP
\fBdirect_mode\fR (\fBCCACHE_DIRECT\fR or \fBCCACHE_NODIRECT\fR, see Boolean values above)
.RS 4
If true, the direct mode will be used\&. The default is true\&. See
THE DIRECT MODE\&.
.RE
.PP
\fBdisable\fR (\fBCCACHE_DISABLE\fR or \fBCCACHE_NODISABLE\fR, see Boolean values above)
.RS 4
When true, ccache will just call the real compiler, bypassing the cache completely\&. The default is false\&.
.RE
.PP
\fBextra_files_to_hash\fR (\fBCCACHE_EXTRAFILES\fR)
.RS 4
This option is a list of paths to files that ccache will include in the the hash sum that identifies the build\&. The list separator is semicolon on Windows systems and colon on other systems\&.
.RE
.PP
\fBfile_clone\fR (\fBCCACHE_FILECLONE\fR or \fBCCACHE_NOFILECLONE\fR, see Boolean values above)
.RS 4
If true, ccache will attempt to use file cloning (also known as \(lqcopy on write\(rq, \(lqCoW\(rq or \(lqreflinks\(rq) to store and fetch cached compiler results\&.
\fBfile_clone\fR
has priority over
\fBhard_link\fR\&. The default is false\&.
.sp
Files stored by cloning cannot be compressed, so the cache size will likely be significantly larger if this option is enabled\&. However, performance may be improved depending on the use case\&.
.sp
Unlike the
\fBhard_link\fR
option,
\fBfile_clone\fR
is completely safe to use, but not all file systems support the feature\&. For such file systems, ccache will fall back to use plain copying (or hard links if
\fBhard_link\fR
is enabled)\&.
.RE
.PP
\fBhard_link\fR (\fBCCACHE_HARDLINK\fR or \fBCCACHE_NOHARDLINK\fR, see Boolean values above)
.RS 4
If true, ccache will attempt to use hard links to store and fetch cached object files\&. The default is false\&.
.sp
Files stored via hard links cannot be compressed, so the cache size will likely be significantly larger if this option is enabled\&. However, performance may be improved depending on the use case\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
Do not enable this option unless you are aware of these caveats:
.sp .5v
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If the resulting file is modified, the file in the cache will also be modified since they share content, which corrupts the cache entry\&. As of version 4\&.0, ccache makes stored and fetched object files read\-only as a safety measure guard\&. Furthermore, a simple integrity check is made for cached object files by verifying that their sizes are correct\&. This means that mistakes like
\fBstrip file\&.o\fR
or
\fBecho >file\&.o\fR
will be detected even if the object file is made writeable, but a modification that doesn\(cqt change the file size will not\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Programs that don\(cqt expect that files from two different identical compilations are hard links to each other can fail\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Programs that rely on modification times (like \(lqmake\(rq) can be confused if several users (or one user with several build trees) use the same cache directory\&. The reason for this is that the object files share i\-nodes and therefore modification times\&. If
\fBfile\&.o\fR
is in build tree A (hard\-linked from the cache) and
\fBfile\&.o\fR
then is produced by ccache in build tree B by hard\-linking from the cache, the modification timestamp will be updated for
\fBfile\&.o\fR
in build tree A as well\&. This can retrigger relinking in build tree A even though nothing really has changed\&.
.RE
.RE
.PP
\fBhash_dir\fR (\fBCCACHE_HASHDIR\fR or \fBCCACHE_NOHASHDIR\fR, see Boolean values above)
.RS 4
If true (which is the default), ccache will include the current working directory (CWD) in the hash that is used to distinguish two compilations when generating debug info (compiler option
\fB\-g\fR
with variations)\&. Exception: The CWD will not be included in the hash if
\fBbase_dir\fR
is set (and matches the CWD) and the compiler option
\fB\-fdebug\-prefix\-map\fR
is used\&. See also the discussion under
COMPILING IN DIFFERENT DIRECTORIES\&.
.sp
The reason for including the CWD in the hash by default is to prevent a problem with the storage of the current working directory in the debug info of an object file, which can lead ccache to return a cached object file that has the working directory in the debug info set incorrectly\&.
.sp
You can disable this option to get cache hits when compiling the same source code in different directories if you don\(cqt mind that CWD in the debug info might be incorrect\&.
.RE
.PP
\fBignore_headers_in_manifest\fR (\fBCCACHE_IGNOREHEADERS\fR)
.RS 4
This option is a list of paths to files (or directories with headers) that ccache will
\fBnot\fR
include in the manifest list that makes up the direct mode\&. Note that this can cause stale cache hits if those headers do indeed change\&. The list separator is semicolon on Windows systems and colon on other systems\&.
.RE
.PP
\fBignore_options\fR (\fBCCACHE_IGNOREOPTIONS\fR)
.RS 4
This option is a space\-delimited list of compiler options that ccache will exclude from the hash\&. Excluding a compiler option from the hash can be useful when you know it doesn\(cqt affect the result (but ccache doesn\(cqt know that), or when it does and you don\(cqt care\&. If a compiler option in the list is suffixed with an asterisk (\fB*\fR) it will be matched as a prefix\&. For example,
\fB\-fmessage\-length=*\fR
will match both
\fB\-fmessage\-length=20\fR
and
\fB\-fmessage\-length=70\fR\&.
.RE
.PP
\fBinode_cache\fR (\fBCCACHE_INODECACHE\fR or \fBCCACHE_NOINODECACHE\fR, see Boolean values above)
.RS 4
If true, enables caching of source file hashes based on device, inode and timestamps\&. This will reduce the time spent on hashing included files as the result can be resused between compilations\&.
.sp
The feature is still experimental and thus off by default\&. It is currently not available on Windows\&.
.sp
The feature requires
\fBtemporary_dir\fR
to be located on a local filesystem\&.
.RE
.PP
\fBkeep_comments_cpp\fR (\fBCCACHE_COMMENTS\fR or \fBCCACHE_NOCOMMENTS\fR, see Boolean values above)
.RS 4
If true, ccache will not discard the comments before hashing preprocessor output\&. This can be used to check documentation with
\fB\-Wdocumentation\fR\&.
.RE
.PP
\fBlimit_multiple\fR (\fBCCACHE_LIMIT_MULTIPLE\fR)
.RS 4
Sets the limit when cleaning up\&. Files are deleted (in LRU order) until the levels are below the limit\&. The default is 0\&.8 (= 80%)\&. See
AUTOMATIC CLEANUP
for more information\&.
.RE
.PP
\fBlog_file\fR (\fBCCACHE_LOGFILE\fR)
.RS 4
If set to a file path, ccache will write information on what it is doing to the specified file\&. This is useful for tracking down problems\&.
.sp
If set to
\fBsyslog\fR, ccache will log using
\fBsyslog()\fR
instead of to a file\&. If you use rsyslogd, you can add something like this to
\fB/etc/rsyslog\&.conf\fR
or a file in
\fB/etc/rsyslog\&.d\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
# log ccache to file
:programname, isequal, "ccache"         /var/log/ccache
# remove from syslog
& ~
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBmax_files\fR (\fBCCACHE_MAXFILES\fR)
.RS 4
This option specifies the maximum number of files to keep in the cache\&. Use 0 for no limit (which is the default)\&. See also
CACHE SIZE MANAGEMENT\&.
.RE
.PP
\fBmax_size\fR (\fBCCACHE_MAXSIZE\fR)
.RS 4
This option specifies the maximum size of the cache\&. Use 0 for no limit\&. The default value is 5G\&. Available suffixes: k, M, G, T (decimal) and Ki, Mi, Gi, Ti (binary)\&. The default suffix is G\&. See also
CACHE SIZE MANAGEMENT\&.
.RE
.PP
\fBpath\fR (\fBCCACHE_PATH\fR)
.RS 4
If set, ccache will search directories in this list when looking for the real compiler\&. The list separator is semicolon on Windows systems and colon on other systems\&. If not set, ccache will look for the first executable matching the compiler name in the normal
\fBPATH\fR
that isn\(cqt a symbolic link to ccache itself\&.
.RE
.PP
\fBpch_external_checksum\fR (\fBCCACHE_PCH_EXTSUM\fR or \fBCCACHE_NOPCH_EXTSUM\fR, see Boolean values above)
.RS 4
When this option is set, and ccache finds a precompiled header file, ccache will look for a file with the extension \(lq\&.sum\(rq added (e\&.g\&. \(lqpre\&.h\&.gch\&.sum\(rq), and if found, it will hash this file instead of the precompiled header itself to work around the performance penalty of hashing very large files\&.
.RE
.PP
\fBprefix_command\fR (\fBCCACHE_PREFIX\fR)
.RS 4
This option adds a list of prefixes (separated by space) to the command line that ccache uses when invoking the compiler\&. See also
USING CCACHE WITH OTHER COMPILER WRAPPERS\&.
.RE
.PP
\fBprefix_command_cpp\fR (\fBCCACHE_PREFIX_CPP\fR)
.RS 4
This option adds a list of prefixes (separated by space) to the command line that ccache uses when invoking the preprocessor\&.
.RE
.PP
\fBread_only\fR (\fBCCACHE_READONLY\fR or \fBCCACHE_NOREADONLY\fR, see Boolean values above)
.RS 4
If true, ccache will attempt to use existing cached results, but it will not add new results to the cache\&. Statistics counters will still be updated, though, unless the
\fBstats\fR
option is set to
\fBfalse\fR\&.
.sp
If you are using this because your ccache directory is read\-only, you need to set
\fBtemporary_dir\fR
since ccache will fail to create temporary files otherwise\&. You may also want to set
\fBstats\fR
to
\fBfalse\fR
make ccache not even try to update stats files\&.
.RE
.PP
\fBread_only_direct\fR (\fBCCACHE_READONLY_DIRECT\fR or \fBCCACHE_NOREADONLY_DIRECT\fR, see Boolean values above)
.RS 4
Just like
\fBread_only\fR
except that ccache will only try to retrieve results from the cache using the direct mode, not the preprocessor mode\&. See documentation for
\fBread_only\fR
regarding using a read\-only ccache directory\&.
.RE
.PP
\fBrecache\fR (\fBCCACHE_RECACHE\fR or \fBCCACHE_NORECACHE\fR, see Boolean values above)
.RS 4
If true, ccache will not use any previously stored result\&. New results will still be cached, possibly overwriting any pre\-existing results\&.
.RE
.PP
\fBrun_second_cpp\fR (\fBCCACHE_CPP2\fR or \fBCCACHE_NOCPP2\fR, see Boolean values above)
.RS 4
If true, ccache will first run the preprocessor to preprocess the source code (see
THE PREPROCESSOR MODE) and then on a cache miss run the compiler on the source code to get hold of the object file\&. This is the default\&.
.sp
If false, ccache will first run preprocessor to preprocess the source code and then on a cache miss run the compiler on the
\fIpreprocessed source code\fR
instead of the original source code\&. This makes cache misses slightly faster since the source code only has to be preprocessed once\&. The downside is that some compilers won\(cqt produce the same result (for instance diagnostics warnings) when compiling preprocessed source code\&.
.sp
A solution to the above mentioned downside is to set
\fBrun_second_cpp\fR
to false and pass
\fB\-fdirectives\-only\fR
(for GCC) or
\fB\-frewrite\-includes\fR
(for Clang) to the compiler\&. This will cause the compiler to leave the macros and other preprocessor information, and only process the
\fB#include\fR
directives\&. When run in this way, the preprocessor arguments will be passed to the compiler since it still has to do
\fIsome\fR
preprocessing (like macros)\&.
.RE
.PP
\fBsloppiness\fR (\fBCCACHE_SLOPPINESS\fR)
.RS 4
By default, ccache tries to give as few false cache hits as possible\&. However, in certain situations it\(cqs possible that you know things that ccache can\(cqt take for granted\&. This option makes it possible to tell ccache to relax some checks in order to increase the hit rate\&. The value should be a comma\-separated string with one or several of the following values:
.PP
\fBclang_index_store\fR
.RS 4
Ignore the Clang compiler option
\fB\-index\-store\-path\fR
and its argument when computing the manifest hash\&. This is useful if you use Xcode, which uses an index store path derived from the local project path\&. Note that the index store won\(cqt be updated correctly on cache hits if you enable this sloppiness\&.
.RE
.PP
\fBfile_stat_matches\fR
.RS 4
Ccache normally examines a file\(cqs contents to determine whether it matches the cached version\&. With this sloppiness set, ccache will consider a file as matching its cached version if the mtimes and ctimes match\&.
.RE
.PP
\fBfile_stat_matches_ctime\fR
.RS 4
Ignore ctimes when
\fBfile_stat_matches\fR
is enabled\&. This can be useful when backdating files\*(Aq mtimes in a controlled way\&.
.RE
.PP
\fBinclude_file_ctime\fR
.RS 4
By default, ccache will not cache a file if it includes a header whose ctime is too new\&. This sloppiness disables that check\&.
.RE
.PP
\fBinclude_file_mtime\fR
.RS 4
By default, ccache will not cache a file if it includes a header whose mtime is too new\&. This sloppiness disables that check\&.
.RE
.PP
\fBlocale\fR
.RS 4
Ccache includes the environment variables
\fBLANG\fR,
\fBLC_ALL\fR,
\fBLC_CTYPE\fR
and
\fBLC_MESSAGES\fR
in the hash by default since they may affect localization of compiler warning messages\&. Set this sloppiness to tell ccache not to do that\&.
.RE
.PP
\fBpch_defines\fR
.RS 4
Be sloppy about
\fB#define\fRs when precompiling a header file\&. See
PRECOMPILED HEADERS
for more information\&.
.RE
.PP
\fBmodules\fR
.RS 4
By default, ccache will not cache compilations if
\fB\-fmodules\fR
is used since it cannot hash the state of compiler\(cqs internal representation of relevant modules\&. This sloppiness allows caching in such a case\&. See
C++ MODULES
for more information\&.
.RE
.PP
\fBsystem_headers\fR
.RS 4
By default, ccache will also include all system headers in the manifest\&. With this sloppiness set, ccache will only include system headers in the hash but not add the system header files to the list of include files\&.
.RE
.PP
\fBtime_macros\fR
.RS 4
Ignore
\fB__DATE__\fR,
\fB__TIME__\fR
and
\fB__TIMESTAMP__\fR
being present in the source code\&.
.RE
.sp
See the discussion under
TROUBLESHOOTING
for more information\&.
.RE
.PP
\fBstats\fR (\fBCCACHE_STATS\fR or \fBCCACHE_NOSTATS\fR, see Boolean values above)
.RS 4
If true, ccache will update the statistics counters on each compilation\&. The default is true\&.
.RE
.PP
\fBtemporary_dir\fR (\fBCCACHE_TEMPDIR\fR)
.RS 4
This option specifies where ccache will put temporary files\&. The default is
\fB/run/user/<UID>/ccache\-tmp\fR
if
\fB/run/user/<UID>\fR
exists, otherwise
\fB<cache_dir>/tmp\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
In previous versions of ccache,
\fBCCACHE_TEMPDIR\fR
had to be on the same filesystem as the
\fBCCACHE_DIR\fR
path, but this requirement has been relaxed\&.)
.sp .5v
.RE
.RE
.PP
\fBumask\fR (\fBCCACHE_UMASK\fR)
.RS 4
This option specifies the umask for files and directories in the cache directory\&. This is mostly useful when you wish to share your cache with other users\&.
.RE
.SH "CACHE SIZE MANAGEMENT"
.sp
By default, ccache has a 5 GB limit on the total size of files in the cache and no limit on the number of files\&. You can set different limits using the command line options \fB\-M\fR/\fB\-\-max\-size\fR and \fB\-F\fR/\fB\-\-max\-files\fR\&. Use \fBccache \-s/\-\-show\-stats\fR to see the cache size and the currently configured limits (in addition to other various statistics)\&.
.sp
Cleanup can be triggered in two different ways: automatic and manual\&.
.SS "Automatic cleanup"
.sp
Ccache maintains counters for various statistics about the cache, including the size and number of all cached files\&. In order to improve performance and reduce issues with concurrent ccache invocations, there is one statistics file for each of the sixteen subdirectories in the cache\&.
.sp
After a new compilation result has been written to the cache, ccache will update the size and file number statistics for the subdirectory (one of sixteen) to which the result was written\&. Then, if the size counter for said subdirectory is greater than \fBmax_size / 16\fR or the file number counter is greater than \fBmax_files / 16\fR, automatic cleanup is triggered\&.
.sp
When automatic cleanup is triggered for a subdirectory in the cache, ccache will:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Count all files in the subdirectory and compute their aggregated size\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Remove files in LRU (least recently used) order until the size is at most
\fBlimit_multiple * max_size / 16\fR
and the number of files is at most
\fBlimit_multiple * max_files / 16\fR, where
\fBlimit_multiple\fR,
\fBmax_size\fR
and
\fBmax_files\fR
are configuration options\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Set the size and file number counters to match the files that were kept\&.
.RE
.sp
The reason for removing more files than just those needed to not exceed the max limits is that a cleanup is a fairly slow operation, so it would not be a good idea to trigger it often, like after each cache miss\&.
.SS "Manual cleanup"
.sp
You can run \fBccache \-c/\-\-cleanup\fR to force cleanup of the whole cache, i\&.e\&. all of the sixteen subdirectories\&. This will recalculate the statistics counters and make sure that the configuration options \fBmax_size\fR and \fBmax_files\fR are not exceeded\&. Note that \fBlimit_multiple\fR is not taken into account for manual cleanup\&.
.SH "CACHE COMPRESSION"
.sp
Ccache will by default compress all data it puts into the cache using the compression algorithm Zstandard (zstd) using compression level 1\&. The algorithm is fast enough that there should be little reason to turn off compression to gain performance\&. One exception is if the cache is located on a compressed file system, in which case the compression performed by ccache of course is redundant\&. See the documentation for the configuration options \fBcompression\fR and \fBcompression_level\fR for more information\&.
.sp
You can use the command line option \fB\-x/\-\-show\-compression\fR to print information related to compression\&. Example:
.sp
.if n \{\
.RS 4
.\}
.nf
Total data:              14\&.8 GB (16\&.0 GB disk blocks)
Compressed data:         11\&.3 GB (30\&.6% of original size)
  \- Original data:       36\&.9 GB
  \- Compression ratio:  3\&.267 x  (69\&.4% space savings)
Incompressible data:      3\&.5 GB
.fi
.if n \{\
.RE
.\}
.sp
Notes:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The \(lqdisk blocks\(rq size is the cache size when taking disk block size into account\&. This value should match the \(lqcache size\(rq value from \(lqccache \-\-show\-stats\(rq\&. The other size numbers refer to actual content sizes\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\(lqCompressed data\(rq refers to result and manifest files stored in the cache\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\(lqIncompressible data\(rq refers to files that are always stored uncompressed (triggered by enabling
\fBfile_clone\fR
or
\fBhard_link\fR) or unknown files (for instance files created by older ccache versions)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The compression ratio is affected by
\fBcompression_level\fR\&.
.RE
.sp
The cache data can also be recompressed to another compression level (or made uncompressed) with the command line option \fB\-X/\-\-recompress\fR\&. If you choose to disable compression by default or to use a low compression level, you can (re)compress newly cached data with a higher compression level after the build or at another time when there are more CPU cycles available, for instance every night\&. Full recompression potentially takes a lot of time, but only files that are currently compressed with a different level than the target level will be recompressed\&.
.SH "CACHE STATISTICS"
.sp
\fBccache \-s/\-\-show\-stats\fR can show the following statistics:
.TS
allbox tab(:);
ltB ltB.
T{
Name
T}:T{
Description
T}
.T&
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
.sp
autoconf compile/link
T}:T{
.sp
Uncachable compilation or linking by an autoconf test\&.
T}
T{
.sp
bad compiler arguments
T}:T{
.sp
Malformed compiler argument, e\&.g\&. missing a value for a compiler option that requires an argument or failure to read a file specified by a compiler option argument\&.
T}
T{
.sp
cache file missing
T}:T{
.sp
A file was unexpectedly missing from the cache\&. This only happens in rare situations, e\&.g\&. if one ccache instance is about to get a file from the cache while another instance removed the file as part of cache cleanup\&.
T}
T{
.sp
cache hit (direct)
T}:T{
.sp
A result was successfully found using the direct mode\&.
T}
T{
.sp
cache hit (preprocessed)
T}:T{
.sp
A result was successfully found using the preprocessor mode\&.
T}
T{
.sp
cache miss
T}:T{
.sp
No result was found\&.
T}
T{
.sp
cache size
T}:T{
.sp
Current size of the cache\&.
T}
T{
.sp
called for link
T}:T{
.sp
The compiler was called for linking, not compiling\&.
T}
T{
.sp
called for preprocessing
T}:T{
.sp
The compiler was called for preprocessing, not compiling\&.
T}
T{
.sp
can\(cqt use precompiled header
T}:T{
.sp
Preconditions for using precompiled headers were not fulfilled\&.
T}
T{
.sp
can\(cqt use modules
T}:T{
.sp
Preconditions for using C++ modules were not fulfilled\&.
T}
T{
.sp
ccache internal error
T}:T{
.sp
Unexpected failure, e\&.g\&. due to problems reading/writing the cache\&.
T}
T{
.sp
cleanups performed
T}:T{
.sp
Number of cleanups performed, either implicitly due to the cache size limit being reached or due to explicit \fBccache \-c/\-\-cleanup\fR calls\&.
T}
T{
.sp
compile failed
T}:T{
.sp
The compilation failed\&. No result stored in the cache\&.
T}
T{
.sp
compiler check failed
T}:T{
.sp
A compiler check program specified by \fBcompiler_check\fR (\fBCCACHE_COMPILERCHECK\fR) failed\&.
T}
T{
.sp
compiler produced empty output
T}:T{
.sp
The compiler\(cqs output file (typically an object file) was empty after compilation\&.
T}
T{
.sp
compiler produced no output
T}:T{
.sp
The compiler\(cqs output file (typically an object file) was missing after compilation\&.
T}
T{
.sp
compiler produced stdout
T}:T{
.sp
The compiler wrote data to standard output\&. This is something that compilers normally never do, so ccache is not designed to store such output in the cache\&.
T}
T{
.sp
couldn\(cqt find the compiler
T}:T{
.sp
The compiler to execute could not be found\&.
T}
T{
.sp
error hashing extra file
T}:T{
.sp
Failure reading a file specified by \fBextra_files_to_hash\fR (\fBCCACHE_EXTRAFILES\fR)\&.
T}
T{
.sp
files in cache
T}:T{
.sp
Current number of files in the cache\&.
T}
T{
.sp
multiple source files
T}:T{
.sp
The compiler was called to compile multiple source files in one go\&. This is not supported by ccache\&.
T}
T{
.sp
no input file
T}:T{
.sp
No input file was specified to the compiler\&.
T}
T{
.sp
output to a non\-regular file
T}:T{
.sp
The output path specified with \fB\-o\fR is not a file (e\&.g\&. a directory or a device node)\&.
T}
T{
.sp
output to stdout
T}:T{
.sp
The compiler was instructed to write its output to standard output using \fB\-o \-\fR\&. This is not supported by ccache\&.
T}
T{
.sp
preprocessor error
T}:T{
.sp
Preprocessing the source code using the compiler\(cqs \fB\-E\fR option failed\&.
T}
T{
.sp
stats updated
T}:T{
.sp
When statistics were updated the last time\&.
T}
T{
.sp
stats zeroed
T}:T{
.sp
When \fBccache \-z\fR was called the last time\&.
T}
T{
.sp
unsupported code directive
T}:T{
.sp
Code like the assembler \fB\&.incbin\fR directive was found\&. This is not supported by ccache\&.
T}
T{
.sp
unsupported compiler option
T}:T{
.sp
A compiler option not supported by ccache was found\&.
T}
T{
.sp
unsupported source language
T}:T{
.sp
A source language e\&.g\&. specified with \fB\-x\fR was unsupported by ccache\&.
T}
.TE
.sp 1
.SH "HOW CCACHE WORKS"
.sp
The basic idea is to detect when you are compiling exactly the same code a second time and reuse the previously produced output\&. The detection is done by hashing different kinds of information that should be unique for the compilation and then using the hash sum to identify the cached output\&. Ccache uses BLAKE3, a very fast cryptographic hash algorithm, for the hashing\&. On a cache hit, ccache is able to supply all of the correct compiler outputs (including all warnings, dependency file, etc) from the cache\&. Data stored in the cache is checksummed with XXH3, an extremely fast non\-cryptographic algorithm, to detect corruption\&.
.sp
Ccache has two ways of gathering information used to look up results in the cache:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the
\fBpreprocessor mode\fR, where ccache runs the preprocessor on the source code and hashes the result
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the
\fBdirect mode\fR, where ccache hashes the source code and include files directly
.RE
.sp
The direct mode is generally faster since running the preprocessor has some overhead\&.
.sp
If no previous result is detected (i\&.e\&., there is a cache miss) using the direct mode, ccache will fall back to the preprocessor mode unless the \fBdepend mode\fR is enabled\&. In the depend mode, ccache never runs the preprocessor, not even on cache misses\&. Read more in THE DEPEND MODE below\&.
.SS "Common hashed information"
.sp
The following information is always included in the hash:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the extension used by the compiler for a file with preprocessor output (normally
\fB\&.i\fR
for C code and
\fB\&.ii\fR
for C++ code)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the compiler\(cqs size and modification time (or other compiler\-specific information specified by
\fBcompiler_check\fR)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the name of the compiler
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the current directory (if
\fBhash_dir\fR
is enabled)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
contents of files specified by
\fBextra_files_to_hash\fR
(if any)
.RE
.SS "The preprocessor mode"
.sp
In the preprocessor mode, the hash is formed of the common information and:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the preprocessor output from running the compiler with
\fB\-E\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the command line options except those that affect include files (\fB\-I\fR,
\fB\-include\fR,
\fB\-D\fR, etc; the theory is that these command line options will change the preprocessor output if they have any effect at all)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
any standard error output generated by the preprocessor
.RE
.sp
Based on the hash, the cached compilation result can be looked up directly in the cache\&.
.SS "The direct mode"
.sp
In the direct mode, the hash is formed of the common information and:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the input source file
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the compiler options
.RE
.sp
Based on the hash, a data structure called \(lqmanifest\(rq is looked up in the cache\&. The manifest contains:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
references to cached compilation results (object file, dependency file, etc) that were produced by previous compilations that matched the hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
paths to the include files that were read at the time the compilation results were stored in the cache
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
hash sums of the include files at the time the compilation results were stored in the cache
.RE
.sp
The current contents of the include files are then hashed and compared to the information in the manifest\&. If there is a match, ccache knows the result of the compilation\&. If there is no match, ccache falls back to running the preprocessor\&. The output from the preprocessor is parsed to find the include files that were read\&. The paths and hash sums of those include files are then stored in the manifest along with information about the produced compilation result\&.
.sp
There is a catch with the direct mode: header files that were used by the compiler are recorded, but header files that were \fBnot\fR used, but would have been used if they existed, are not\&. So, when ccache checks if a result can be taken from the cache, it currently can\(cqt check if the existence of a new header file should invalidate the result\&. In practice, the direct mode is safe to use in the absolute majority of cases\&.
.sp
The direct mode will be disabled if any of the following holds:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBdirect_mode\fR
is false
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a modification time of one of the include files is too new (needed to avoid a race condition)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a compiler option not supported by the direct mode is used:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a
\fB\-Wp,\fR\fB\fIX\fR\fR
compiler option other than
\fB\-Wp,\-MD,\fR\fB\fIpath\fR\fR,
\fB\-Wp,\-MMD,\fR\fB\fIpath\fR\fR
and
\fB\-Wp,\-D_define_\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-Xpreprocessor\fR
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the string
\fB__TIME__\fR
is present in the source code
.RE
.SS "The depend mode"
.sp
If the depend mode is enabled, ccache will not use the preprocessor at all\&. The hash used to identify results in the cache will be based on the direct mode hash described above plus information about include files read from the dependency file generated by the compiler with \fB\-MD\fR or \fB\-MMD\fR\&.
.sp
Advantages:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The ccache overhead of a cache miss will be much smaller\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Not running the preprocessor at all can be good if compilation is performed remotely, for instance when using distcc or similar; ccache then won\(cqt make potentially costly preprocessor calls on the local machine\&.
.RE
.sp
Disadvantages:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The cache hit rate will likely be lower since any change to compiler options or source code will make the hash different\&. Compare this with the default setup where ccache will fall back to the preprocessor mode, which is tolerant to some types of changes of compiler options and source code changes\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \-MD is used, the manifest entries will include system header files as well, thus slowing down cache hits slightly, just as using \-MD slows down make\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \-MMD is used, the manifest entries will not include system header files, which means ccache will ignore changes in them\&.
.RE
.sp
The depend mode will be disabled if any of the following holds:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBdepend_mode\fR
is false\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBrun_second_cpp\fR
is false\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The compiler is not generating dependencies using
\fB\-MD\fR
or
\fB\-MMD\fR\&.
.RE
.SH "CACHE DEBUGGING"
.sp
To find out what information ccache actually is hashing, you can enable the debug mode via the configuration option \fBdebug\fR or by setting \fBCCACHE_DEBUG\fR in the environment\&. This can be useful if you are investigating why you don\(cqt get cache hits\&. Note that performance will be reduced slightly\&.
.sp
When the debug mode is enabled, ccache will create up to five additional files next to the object file:
.TS
allbox tab(:);
ltB ltB.
T{
Filename
T}:T{
Description
T}
.T&
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
.sp
\fB<objectfile>\&.ccache\-input\-c\fR
T}:T{
.sp
Binary input hashed by both the direct mode and the preprocessor mode\&.
T}
T{
.sp
\fB<objectfile>\&.ccache\-input\-d\fR
T}:T{
.sp
Binary input only hashed by the direct mode\&.
T}
T{
.sp
\fB<objectfile>\&.ccache\-input\-p\fR
T}:T{
.sp
Binary input only hashed by the preprocessor mode\&.
T}
T{
.sp
\fB<objectfile>\&.ccache\-input\-text\fR
T}:T{
.sp
Human\-readable combined diffable text version of the three files above\&.
T}
T{
.sp
\fB<objectfile>\&.ccache\-log\fR
T}:T{
.sp
Log for this object file\&.
T}
.TE
.sp 1
.sp
In the direct mode, ccache uses the 160 bit BLAKE3 hash of the \fBccache\-input\-c\fR + \fBccache\-input\-d\fR data (where \fB+\fR means concatenation), while the \fBccache\-input\-c\fR + \fBccache\-input\-p\fR data is used in the preprocessor mode\&.
.sp
The \fBccache\-input\-text\fR file is a combined text version of the three binary input files\&. It has three sections (\(lqCOMMON\(rq, \(lqDIRECT MODE\(rq and \(lqPREPROCESSOR MODE\(rq), which is turn contain annotations that say what kind of data comes next\&.
.sp
To debug why you don\(cqt get an expected cache hit for an object file, you can do something like this:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Build with debug mode enabled\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Save the
\fB<objectfile>\&.ccache\-*\fR
files\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Build again with debug mode enabled\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Compare
\fB<objectfile>\&.ccache\-input\-text\fR
for the two builds\&. This together with the
\fB<objectfile>\&.ccache\-log\fR
files should give you some clues about what is happening\&.
.RE
.SH "COMPILING IN DIFFERENT DIRECTORIES"
.sp
Some information included in the hash that identifies a unique compilation can contain absolute paths:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The preprocessed source code may contain absolute paths to include files if the compiler option
\fB\-g\fR
is used or if absolute paths are given to
\fB\-I\fR
and similar compiler options\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Paths specified by compiler options (such as
\fB\-I\fR,
\fB\-MF\fR, etc) on the command line may be absolute\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The source code file path may be absolute, and that path may substituted for
\fB__FILE__\fR
macros in the source code or included in warnings emitted to standard error by the preprocessor\&.
.RE
.sp
This means that if you compile the same code in different locations, you can\(cqt share compilation results between the different build directories since you get cache misses because of the absolute build directory paths that are part of the hash\&.
.sp
Here\(cqs what can be done to enable cache hits between different build directories:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If you build with
\fB\-g\fR
(or similar) to add debug information to the object file, you must either:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
use the compiler option
\fB\-fdebug\-prefix\-map=\fR\fB\fIold\fR\fR\fB=\fR\fB\fInew\fR\fR
for relocating debug info to a common prefix (e\&.g\&.
\fB\-fdebug\-prefix\-map=$PWD=\&.\fR); or
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
set
\fBhash_dir = false\fR\&.
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If you use absolute paths anywhere on the command line (e\&.g\&. the source code file path or an argument to compiler options like
\fB\-I\fR
and
\fB\-MF\fR), you must set
\fBbase_dir\fR
to an absolute path to a \(lqbase directory\(rq\&. Ccache will then rewrite absolute paths under that directory to relative before computing the hash\&.
.RE
.SH "PRECOMPILED HEADERS"
.sp
Ccache has support for GCC\(cqs precompiled headers\&. However, you have to do some things to make it work properly:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
You must set
\fBsloppiness\fR
to
\fBpch_defines,time_macros\fR\&. The reason is that ccache can\(cqt tell whether
\fB__TIME__\fR,
\fB__DATE__\fR
or
\fB__TIMESTAMP__\fR
is used when using a precompiled header\&. Further, it can\(cqt detect changes in
\fB#define\fRs in the source code because of how preprocessing works in combination with precompiled headers\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
You must either:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
use the compiler option
\fB\-include\fR
to include the precompiled header (i\&.e\&., don\(cqt use
\fB#include\fR
in the source code to include the header; the filename itself must be sufficient to find the header, i\&.e\&.
\fB\-I\fR
paths are not searched); or
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
(for the Clang compiler) use the compiler option
\fB\-include\-pch\fR
to include the PCH file generated from the precompiled header; or
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
(for the GCC compiler) add the compiler option
\fB\-fpch\-preprocess\fR
when compiling\&.
.RE
.sp
If you don\(cqt do this, either the non\-precompiled version of the header file will be used (if available) or ccache will fall back to running the real compiler and increase the statistics counter \(lqpreprocessor error\(rq (if the non\-precompiled header file is not available)\&.
.RE
.SH "C++ MODULES"
.sp
Ccache has support for Clang\(cqs \fB\-fmodules\fR option\&. In practice ccache only additionally hashes \fBmodule\&.modulemap\fR files; it does not know how Clang handles its cached binary form of modules so those are ignored\&. This should not matter in practice: as long as everything else (including \fBmodule\&.modulemap\fR files) is the same the cached result should work\&. Still, you must set \fBsloppiness\fR to \fBmodules\fR to allow caching\&.
.sp
You must use both \fBdirect mode\fR and \fBdepend mode\fR\&. When using the preprocessor mode Clang does not provide enough information to allow hashing of \fBmodule\&.modulemap\fR files\&.
.SH "SHARING A CACHE"
.sp
A group of developers can increase the cache hit rate by sharing a cache directory\&. To share a cache without unpleasant side effects, the following conditions should to be met:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Use the same cache directory\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Make sure that the configuration option
\fBhard_link\fR
is false (which is the default)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Make sure that all users are in the same group\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Set the configuration option
\fBumask\fR
to 002\&. This ensures that cached files are accessible to everyone in the group\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Make sure that all users have write permission in the entire cache directory (and that you trust all users of the shared cache)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Make sure that the setgid bit is set on all directories in the cache\&. This tells the filesystem to inherit group ownership for new directories\&. The following command might be useful for this:
.sp
.if n \{\
.RS 4
.\}
.nf
find $CCACHE_DIR \-type d | xargs chmod g+s
.fi
.if n \{\
.RE
.\}
.RE
.sp
The reason to avoid the hard link mode is that the hard links cause unwanted side effects, as all links to a cached file share the file\(cqs modification timestamp\&. This results in false dependencies to be triggered by timestamp\-based build systems whenever another user links to an existing file\&. Typically, users will see that their libraries and binaries are relinked without reason\&.
.sp
You may also want to make sure that a base directory is set appropriately, as discussed in a previous section\&.
.SH "SHARING A CACHE ON NFS"
.sp
It is possible to put the cache directory on an NFS filesystem (or similar filesystems), but keep in mind that:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Having the cache on NFS may slow down compilation\&. Make sure to do some benchmarking to see if it\(cqs worth it\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Ccache hasn\(cqt been tested very thoroughly on NFS\&.
.RE
.sp
A tip is to set \fBtemporary_dir\fR to a directory on the local host to avoid NFS traffic for temporary files\&.
.sp
It is recommended to use the same operating system version when using a shared cache\&. If operating system versions are different then system include files will likely be different and there will be few or no cache hits between the systems\&. One way of improving cache hit rate in that case is to set \fBsloppiness\fR to \fBsystem_headers\fR to ignore system headers\&.
.SH "USING CCACHE WITH OTHER COMPILER WRAPPERS"
.sp
The recommended way of combining ccache with another compiler wrapper (such as \(lqdistcc\(rq) is by letting ccache execute the compiler wrapper\&. This is accomplished by defining \fBprefix_command\fR, for example by setting the environment variable \fBCCACHE_PREFIX\fR to the name of the wrapper (e\&.g\&. \fBdistcc\fR)\&. Ccache will then prefix the command line with the specified command when running the compiler\&. To specify several prefix commands, set \fBprefix_command\fR to a colon\-separated list of commands\&.
.sp
Unless you set \fBcompiler_check\fR to a suitable command (see the description of that configuration option), it is not recommended to use the form \fBccache anotherwrapper compiler args\fR as the compilation command\&. It\(cqs also not recommended to use the masquerading technique for the other compiler wrapper\&. The reason is that by default, ccache will in both cases hash the mtime and size of the other wrapper instead of the real compiler, which means that:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Compiler upgrades will not be detected properly\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The cached results will not be shared between compilations with and without the other wrapper\&.
.RE
.sp
Another minor thing is that if \fBprefix_command\fR is used, ccache will not invoke the other wrapper when running the preprocessor, which increases performance\&. You can use \fBprefix_command_cpp\fR if you also want to invoke the other wrapper when doing preprocessing (normally by adding \fB\-E\fR)\&.
.SH "CAVEATS"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The direct mode fails to pick up new header files in some rare scenarios\&. See
THE DIRECT MODE
above\&.
.RE
.SH "TROUBLESHOOTING"
.SS "General"
.sp
A general tip for getting information about what ccache is doing is to enable debug logging by setting the configuration option \fBdebug\fR (or the environment variable \fBCCACHE_DEBUG\fR); see debugging for more information\&. Another way of keeping track of what is happening is to check the output of \fBccache \-s\fR\&.
.SS "Performance"
.sp
Ccache has been written to perform well out of the box, but sometimes you may have to do some adjustments of how you use the compiler and ccache in order to improve performance\&.
.sp
Since ccache works best when I/O is fast, put the cache directory on a fast storage device if possible\&. Having lots of free memory so that files in the cache directory stay in the disk cache is also preferable\&.
.sp
A good way of monitoring how well ccache works is to run \fBccache \-s\fR before and after your build and then compare the statistics counters\&. Here are some common problems and what may be done to increase the hit rate:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \(lqcache hit (preprocessed)\(rq has been incremented instead of \(lqcache hit (direct)\(rq, ccache has fallen back to preprocessor mode, which is generally slower\&. Some possible reasons are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The source code has been modified in such a way that the preprocessor output is not affected\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Compiler arguments that are hashed in the direct mode but not in the preprocessor mode have changed (\fB\-I\fR,
\fB\-include\fR,
\fB\-D\fR, etc) and they didn\(cqt affect the preprocessor output\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The compiler option
\fB\-Xpreprocessor\fR
or
\fB\-Wp,\fR\fB\fIX\fR\fR
(except
\fB\-Wp,\-MD,\fR\fB\fIpath\fR\fR,
\fB\-Wp,\-MMD,\fR\fB\fIpath\fR\fR, and
\fB\-Wp,\-D_define_\fR) is used\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
This was the first compilation with a new value of the
base directory\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A modification time of one of the include files is too new (created the same second as the compilation is being done)\&. This check is made to avoid a race condition\&. To fix this, create the include file earlier in the build process, if possible, or set
\fBsloppiness\fR
to
\fBinclude_file_ctime, include_file_mtime\fR
if you are willing to take the risk\&. (The race condition consists of these events: the preprocessor is run; an include file is modified by someone; the new include file is hashed by ccache; the real compiler is run on the preprocessor\(cqs output, which contains data from the old header file; the wrong object file is stored in the cache\&.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The
\fB__TIME__\fR
preprocessor macro is (potentially) being used\&. Ccache turns off direct mode if
\fB__TIME__\fR
is present in the source code\&. This is done as a safety measure since the string indicates that a
\fB__TIME__\fR
macro
\fImay\fR
affect the output\&. (To be sure, ccache would have to run the preprocessor, but the sole point of the direct mode is to avoid that\&.) If you know that
\fB__TIME__\fR
isn\(cqt used in practise, or don\(cqt care if ccache produces objects where
\fB__TIME__\fR
is expanded to something in the past, you can set
\fBsloppiness\fR
to
\fBtime_macros\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The
\fB__DATE__\fR
preprocessor macro is (potentially) being used and the date has changed\&. This is similar to how
\fB__TIME__\fR
is handled\&. If
\fB__DATE__\fR
is present in the source code, ccache hashes the current date in order to be able to produce the correct object file if the
\fB__DATE__\fR
macro affects the output\&. If you know that
\fB__DATE__\fR
isn\(cqt used in practise, or don\(cqt care if ccache produces objects where
\fB__DATE__\fR
is expanded to something in the past, you can set
\fBsloppiness\fR
to
\fBtime_macros\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The
\fB__TIMESTAMP__\fR
preprocessor macro is (potentially) being used and the source file\(cqs modification time has changed\&. This is similar to how
\fB__TIME__\fR
is handled\&. If
\fB__TIMESTAMP__\fR
is present in the source code, ccache hashes the string representation of the source file\(cqs modification time in order to be able to produce the correct object file if the
\fB__TIMESTAMP__\fR
macro affects the output\&. If you know that
\fB__TIMESTAMP__\fR
isn\(cqt used in practise, or don\(cqt care if ccache produces objects where
\fB__TIMESTAMP__\fR
is expanded to something in the past, you can set
\fBsloppiness\fR
to
\fBtime_macros\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The input file path has changed\&. Ccache includes the input file path in the direct mode hash to be able to take relative include files into account and to produce a correct object file if the source code includes a
\fB__FILE__\fR
macro\&.
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \(lqcache miss\(rq has been incremented even though the same code has been compiled and cached before, ccache has either detected that something has changed anyway or a cleanup has been performed (either explicitly or implicitly when a cache limit has been reached)\&. Some perhaps unobvious things that may result in a cache miss are usage of
\fB__TIME__\fR,
\fB__DATE__\fR
or
\fB__TIMESTAMP__\fR
macros, or use of automatically generated code that contains a timestamp, build counter or other volatile information\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \(lqmultiple source files\(rq has been incremented, it\(cqs an indication that the compiler has been invoked on several source code files at once\&. Ccache doesn\(cqt support that\&. Compile the source code files separately if possible\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \(lqunsupported compiler option\(rq has been incremented, enable debug logging and check which compiler option was rejected\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \(lqpreprocessor error\(rq has been incremented, one possible reason is that precompiled headers are being used\&. See
PRECOMPILED HEADERS
for how to remedy this\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \(lqcan\(cqt use precompiled header\(rq has been incremented, see
PRECOMPILED HEADERS\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If \(lqcan\(cqt use modules\(rq has been incremented, see
C++ MODULES\&.
.RE
.SS "Corrupt object files"
.sp
It should be noted that ccache is susceptible to general storage problems\&. If a bad object file sneaks into the cache for some reason, it will of course stay bad\&. Some possible reasons for erroneous object files are bad hardware (disk drive, disk controller, memory, etc), buggy drivers or file systems, a bad \fBprefix_command\fR or compiler wrapper\&. If this happens, the easiest way of fixing it is this:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Build so that the bad object file ends up in the build tree\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Remove the bad object file from the build tree\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Rebuild with
\fBCCACHE_RECACHE\fR
set\&.
.RE
.sp
An alternative is to clear the whole cache with \fBccache \-C\fR if you don\(cqt mind losing other cached results\&.
.sp
There are no reported issues about ccache producing broken object files reproducibly\&. That doesn\(cqt mean it can\(cqt happen, so if you find a repeatable case, please report it\&.
.SH "MORE INFORMATION"
.sp
Credits, mailing list information, bug reporting instructions, source code, etc, can be found on ccache\(cqs web site: https://ccache\&.dev\&.
.SH "AUTHOR"
.sp
Ccache was originally written by Andrew Tridgell and is currently developed and maintained by Joel Rosdahl\&. See AUTHORS\&.txt or AUTHORS\&.html and https://ccache\&.dev/credits\&.html for a list of contributors\&.
